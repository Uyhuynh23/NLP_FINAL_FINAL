<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/k2fsa/sherpa/onnx/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/k2fsa/sherpa/onnx/MainActivity.kt" />
              <option name="originalContent" value="package com.k2fsa.sherpa.onnx&#10;&#10;import android.animation.ObjectAnimator&#10;import android.content.res.AssetManager&#10;import android.graphics.Color&#10;import android.media.AudioAttributes&#10;import android.media.AudioFormat&#10;import android.media.AudioManager&#10;import android.media.AudioTrack&#10;import android.media.MediaPlayer&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.view.animation.AccelerateDecelerateInterpolator&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.view.WindowCompat&#10;import com.airbnb.lottie.LottieAnimationView&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.text.Normalizer&#10;&#10;const val TAG = &quot;sherpa-onnx&quot;&#10;&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var tts: OfflineTts&#10;    private lateinit var text: EditText&#10;    private lateinit var sid: EditText&#10;    private lateinit var speed: EditText&#10;    private lateinit var generate: Button&#10;    private lateinit var play: Button&#10;    private lateinit var stop: Button&#10;    private var stopped: Boolean = false&#10;    private var mediaPlayer: MediaPlayer? = null&#10;&#10;    // UI Animation elements&#10;    private lateinit var lottieMic: LottieAnimationView&#10;    private lateinit var lottieWaveform: LottieAnimationView&#10;    private lateinit var statusText: TextView&#10;    private lateinit var mainCard: CardView&#10;&#10;    // see&#10;    // https://developer.android.com/reference/kotlin/android/media/AudioTrack&#10;    private lateinit var track: AudioTrack&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Enable edge-to-edge display&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;        window.statusBarColor = Color.TRANSPARENT&#10;        window.navigationBarColor = Color.TRANSPARENT&#10;&#10;        setContentView(R.layout.activity_main)&#10;&#10;        Log.i(TAG, &quot;Start to initialize TTS&quot;)&#10;        initTts()&#10;        Log.i(TAG, &quot;Finish initializing TTS&quot;)&#10;&#10;        Log.i(TAG, &quot;Start to initialize AudioTrack&quot;)&#10;        initAudioTrack()&#10;        Log.i(TAG, &quot;Finish initializing AudioTrack&quot;)&#10;&#10;        initViews()&#10;        setupClickListeners()&#10;        startEntranceAnimations()&#10;&#10;        // Set default values for hidden fields&#10;        sid.setText(&quot;0&quot;)&#10;        speed.setText(&quot;1.0&quot;)&#10;&#10;        // Vietnamese sample text for testing TTS&#10;        val sampleText = &quot;Xin chào, tôi là trợ lý ảo. Rất vui được gặp bạn. Hôm nay thời tiết rất đẹp.&quot;&#10;        text.setText(sampleText)&#10;&#10;        play.isEnabled = false&#10;        updatePlayButtonState()&#10;    }&#10;&#10;    private fun initViews() {&#10;        text = findViewById(R.id.text)&#10;        sid = findViewById(R.id.sid)&#10;        speed = findViewById(R.id.speed)&#10;        generate = findViewById(R.id.generate)&#10;        play = findViewById(R.id.play)&#10;        stop = findViewById(R.id.stop)&#10;&#10;        // Animation elements&#10;        lottieMic = findViewById(R.id.lottie_mic)&#10;        lottieWaveform = findViewById(R.id.lottie_waveform)&#10;        statusText = findViewById(R.id.status_text)&#10;        mainCard = findViewById(R.id.main_card)&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        generate.setOnClickListener {&#10;            animateButtonPress(it)&#10;            onClickGenerate()&#10;        }&#10;        play.setOnClickListener {&#10;            animateButtonPress(it)&#10;            onClickPlay()&#10;        }&#10;        stop.setOnClickListener {&#10;            animateButtonPress(it)&#10;            onClickStop()&#10;        }&#10;    }&#10;&#10;    private fun animateButtonPress(view: View) {&#10;        view.animate()&#10;            .scaleX(0.95f)&#10;            .scaleY(0.95f)&#10;            .setDuration(100)&#10;            .withEndAction {&#10;                view.animate()&#10;                    .scaleX(1f)&#10;                    .scaleY(1f)&#10;                    .setDuration(100)&#10;                    .start()&#10;            }&#10;            .start()&#10;    }&#10;&#10;    private fun startEntranceAnimations() {&#10;        // Card entrance animation&#10;        mainCard.alpha = 0f&#10;        mainCard.translationY = 100f&#10;        mainCard.animate()&#10;            .alpha(1f)&#10;            .translationY(0f)&#10;            .setDuration(500)&#10;            .setStartDelay(200)&#10;            .setInterpolator(AccelerateDecelerateInterpolator())&#10;            .start()&#10;    }&#10;&#10;    private fun showGeneratingState() {&#10;        runOnUiThread {&#10;            lottieWaveform.visibility = View.VISIBLE&#10;            lottieWaveform.playAnimation()&#10;            statusText.visibility = View.VISIBLE&#10;            statusText.text = &quot;️ Generating speech...&quot;&#10;            statusText.animate().alpha(1f).setDuration(200).start()&#10;        }&#10;    }&#10;&#10;    private fun hideGeneratingState() {&#10;        runOnUiThread {&#10;            lottieWaveform.pauseAnimation()&#10;            lottieWaveform.visibility = View.GONE&#10;            statusText.text = &quot;✅ Speech generated successfully!&quot;&#10;            statusText.postDelayed({&#10;                statusText.animate().alpha(0f).setDuration(300).withEndAction {&#10;                    statusText.visibility = View.GONE&#10;                }.start()&#10;            }, 2000)&#10;        }&#10;    }&#10;&#10;    private fun updatePlayButtonState() {&#10;        if (play.isEnabled) {&#10;            play.alpha = 1f&#10;        } else {&#10;            play.alpha = 0.5f&#10;        }&#10;    }&#10;&#10;    private fun initAudioTrack() {&#10;        val sampleRate = tts.sampleRate()&#10;        val bufLength = AudioTrack.getMinBufferSize(&#10;            sampleRate,&#10;            AudioFormat.CHANNEL_OUT_MONO,&#10;            AudioFormat.ENCODING_PCM_FLOAT&#10;        )&#10;        Log.i(TAG, &quot;sampleRate: $sampleRate, buffLength: $bufLength&quot;)&#10;&#10;        val attr = AudioAttributes.Builder().setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)&#10;            .setUsage(AudioAttributes.USAGE_MEDIA)&#10;            .build()&#10;&#10;        val format = AudioFormat.Builder()&#10;            .setEncoding(AudioFormat.ENCODING_PCM_FLOAT)&#10;            .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)&#10;            .setSampleRate(sampleRate)&#10;            .build()&#10;&#10;        track = AudioTrack(&#10;            attr, format, bufLength, AudioTrack.MODE_STREAM,&#10;            AudioManager.AUDIO_SESSION_ID_GENERATE&#10;        )&#10;        track.play()&#10;    }&#10;&#10;    // this function is called from C++&#10;    private fun callback(samples: FloatArray): Int {&#10;        if (!stopped) {&#10;            track.write(samples, 0, samples.size, AudioTrack.WRITE_BLOCKING)&#10;            return 1&#10;        } else {&#10;            track.stop()&#10;            return 0&#10;        }&#10;    }&#10;&#10;    private fun onClickGenerate() {&#10;        val sidInt = sid.text.toString().toIntOrNull()&#10;        if (sidInt == null || sidInt &lt; 0) {&#10;            Toast.makeText(&#10;                applicationContext,&#10;                &quot;Please input a non-negative integer for speaker ID!&quot;,&#10;                Toast.LENGTH_SHORT&#10;            ).show()&#10;            return&#10;        }&#10;&#10;        val speedFloat = speed.text.toString().toFloatOrNull()&#10;        if (speedFloat == null || speedFloat &lt;= 0) {&#10;            Toast.makeText(&#10;                applicationContext,&#10;                &quot;Please input a positive number for speech speed!&quot;,&#10;                Toast.LENGTH_SHORT&#10;            ).show()&#10;            return&#10;        }&#10;&#10;        var textStr = text.text.toString().trim()&#10;        if (textStr.isBlank() || textStr.isEmpty()) {&#10;            Toast.makeText(applicationContext, &quot;Please input a non-empty text!&quot;, Toast.LENGTH_SHORT)&#10;                .show()&#10;            return&#10;        }&#10;&#10;        // Normalize Vietnamese text to NFC form for proper diacritic handling&#10;        textStr = Normalizer.normalize(textStr, Normalizer.Form.NFC)&#10;&#10;        track.pause()&#10;        track.flush()&#10;        track.play()&#10;&#10;        play.isEnabled = false&#10;        generate.isEnabled = false&#10;        stopped = false&#10;        showGeneratingState()&#10;        Thread {&#10;            val audio = tts.generateWithCallback(&#10;                text = textStr,&#10;                sid = sidInt,&#10;                speed = speedFloat,&#10;                callback = this::callback&#10;            )&#10;&#10;            val filename = application.filesDir.absolutePath + &quot;/generated.wav&quot;&#10;            val ok = audio.samples.size &gt; 0 &amp;&amp; audio.save(filename)&#10;            if (ok) {&#10;                runOnUiThread {&#10;                    hideGeneratingState()&#10;                    play.isEnabled = true&#10;                    generate.isEnabled = true&#10;                    track.stop()&#10;                }&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    private fun onClickPlay() {&#10;        val filename = application.filesDir.absolutePath + &quot;/generated.wav&quot;&#10;        mediaPlayer?.stop()&#10;        mediaPlayer = MediaPlayer.create(&#10;            applicationContext,&#10;            Uri.fromFile(File(filename))&#10;        )&#10;        mediaPlayer?.start()&#10;    }&#10;&#10;    private fun onClickStop() {&#10;        stopped = true&#10;        play.isEnabled = true&#10;        generate.isEnabled = true&#10;        track.pause()&#10;        track.flush()&#10;        mediaPlayer?.stop()&#10;        mediaPlayer = null&#10;    }&#10;&#10;    private fun initTts() {&#10;        var modelDir: String?&#10;        var modelName: String?&#10;        var acousticModelName: String?&#10;        var vocoder: String?&#10;        var voices: String?&#10;        var ruleFsts: String?&#10;        var ruleFars: String?&#10;        var lexicon: String?&#10;        var dataDir: String?&#10;        var assets: AssetManager? = application.assets&#10;        var isKitten = false&#10;&#10;        // The purpose of such a design is to make the CI test easier&#10;        // Please see&#10;        // https://github.com/k2-fsa/sherpa-onnx/blob/master/scripts/apk/generate-tts-apk-script.py&#10;&#10;        // VITS -- begin&#10;        modelName = null&#10;        // VITS -- end&#10;&#10;        // Matcha -- begin&#10;        acousticModelName = null&#10;        vocoder = null&#10;        // Matcha -- end&#10;&#10;        // For Kokoro -- begin&#10;        voices = null&#10;        // For Kokoro -- end&#10;&#10;&#10;        modelDir = null&#10;        ruleFsts = null&#10;        ruleFars = null&#10;        lexicon = null&#10;        dataDir = null&#10;&#10;//&#10;//        modelDir = &quot;exported&quot;&#10;//        modelName = &quot;model_fixed.onnx&quot;&#10;//        dataDir = &quot;exported/espeak-ng-data&quot;&#10;&#10;        // Working Piper model (backup):&#10;         modelDir = &quot;vits-piper-vi_VN-vais1000-medium&quot;&#10;         modelName = &quot;vi_VN-vais1000-medium.onnx&quot;&#10;         dataDir = &quot;vits-piper-vi_VN-vais1000-medium/espeak-ng-data&quot;&#10;&#10;        // Example 1:&#10;        // modelDir = &quot;vits-vctk&quot;&#10;        // modelName = &quot;vits-vctk.onnx&quot;&#10;        // lexicon = &quot;lexicon.txt&quot;&#10;&#10;        // Example 2:&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/tag/tts-models&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/vits-piper-en_US-amy-low.tar.bz2&#10;        // modelDir = &quot;vits-piper-en_US-amy-low&quot;&#10;        // modelName = &quot;en_US-amy-low.onnx&quot;&#10;        // dataDir = &quot;vits-piper-en_US-amy-low/espeak-ng-data&quot;&#10;&#10;        // Example 3:&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/vits-icefall-zh-aishell3.tar.bz2&#10;        // modelDir = &quot;vits-icefall-zh-aishell3&quot;&#10;        // modelName = &quot;model.onnx&quot;&#10;        // ruleFars = &quot;vits-icefall-zh-aishell3/rule.far&quot;&#10;        // lexicon = &quot;lexicon.txt&quot;&#10;&#10;        // Example 4:&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/vits.html#csukuangfj-vits-zh-hf-fanchen-c-chinese-187-speakers&#10;        // modelDir = &quot;vits-zh-hf-fanchen-C&quot;&#10;        // modelName = &quot;vits-zh-hf-fanchen-C.onnx&quot;&#10;        // lexicon = &quot;lexicon.txt&quot;&#10;&#10;        // Example 5:&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/vits-coqui-de-css10.tar.bz2&#10;        // modelDir = &quot;vits-coqui-de-css10&quot;&#10;        // modelName = &quot;model.onnx&quot;&#10;&#10;        // Example 6&#10;        // vits-melo-tts-zh_en&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/vits.html#vits-melo-tts-zh-en-chinese-english-1-speaker&#10;        // modelDir = &quot;vits-melo-tts-zh_en&quot;&#10;        // modelName = &quot;model.onnx&quot;&#10;        // lexicon = &quot;lexicon.txt&quot;&#10;&#10;        // Example 7&#10;        // matcha-icefall-zh-baker&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/matcha.html#matcha-icefall-zh-baker-chinese-1-female-speaker&#10;        // modelDir = &quot;matcha-icefall-zh-baker&quot;&#10;        // acousticModelName = &quot;model-steps-3.onnx&quot;&#10;        // vocoder = &quot;vocos-22khz-univ.onnx&quot;    // Vocoder should be downloaded separately; place in the **root directory of your resources folder**, not under modelDir.&#10;        // lexicon = &quot;lexicon.txt&quot;&#10;&#10;        // Example 8&#10;        // matcha-icefall-en_US-ljspeech&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/matcha.html#matcha-icefall-en-us-ljspeech-american-english-1-female-speaker&#10;        // modelDir = &quot;matcha-icefall-en_US-ljspeech&quot;&#10;        // acousticModelName = &quot;model-steps-3.onnx&quot;&#10;        // vocoder = &quot;vocos-22khz-univ.onnx&quot;&#10;        // dataDir = &quot;matcha-icefall-en_US-ljspeech/espeak-ng-data&quot;&#10;&#10;        // Example 9&#10;        // kokoro-en-v0_19&#10;        // modelDir = &quot;kokoro-en-v0_19&quot;&#10;        // modelName = &quot;model.onnx&quot;&#10;        // voices = &quot;voices.bin&quot;&#10;        // dataDir = &quot;kokoro-en-v0_19/espeak-ng-data&quot;&#10;&#10;        // Example 10&#10;        // kokoro-multi-lang-v1_0&#10;        // modelDir = &quot;kokoro-multi-lang-v1_0&quot;&#10;        // modelName = &quot;model.onnx&quot;&#10;        // voices = &quot;voices.bin&quot;&#10;        // dataDir = &quot;kokoro-multi-lang-v1_0/espeak-ng-data&quot;&#10;        // lexicon = &quot;kokoro-multi-lang-v1_0/lexicon-us-en.txt,kokoro-multi-lang-v1_0/lexicon-zh.txt&quot;&#10;        // ruleFsts = &quot;$modelDir/phone-zh.fst,$modelDir/date-zh.fst,$modelDir/number-zh.fst&quot;&#10;&#10;        // Example 11&#10;        // kitten-nano-en-v0_1-fp16&#10;        // modelDir = &quot;kitten-nano-en-v0_1-fp16&quot;&#10;        // modelName = &quot;model.fp16.onnx&quot;&#10;        // voices = &quot;voices.bin&quot;&#10;        // dataDir = &quot;kokoro-multi-lang-v1_0/espeak-ng-data&quot;&#10;        // isKitten = true&#10;&#10;        // Example 12&#10;        // matcha-icefall-zh-en&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/all/Chinese-English/matcha-icefall-zh-en.html&#10;        // modelDir = &quot;matcha-icefall-zh-en&quot;&#10;        // acousticModelName = &quot;model-steps-3.onnx&quot;&#10;        // vocoder = &quot;vocos-16khz-univ.onnx&quot;    // Vocoder should be downloaded separately; place in the **root directory of your resources folder**, not under modelDir.&#10;        // dataDir = &quot;matcha-icefall-zh-en/espeak-ng-data&quot;&#10;        // lexicon = &quot;lexicon.txt&quot;&#10;&#10;        if (dataDir != null) {&#10;            val newDir = copyDataDir(dataDir!!)&#10;            dataDir = &quot;$newDir/$dataDir&quot;&#10;        }&#10;&#10;        val config = getOfflineTtsConfig(&#10;            modelDir = modelDir!!,&#10;            modelName = modelName ?: &quot;&quot;,&#10;            acousticModelName = acousticModelName ?: &quot;&quot;,&#10;            vocoder = vocoder ?: &quot;&quot;,&#10;            voices = voices ?: &quot;&quot;,&#10;            lexicon = lexicon ?: &quot;&quot;,&#10;            dataDir = dataDir ?: &quot;&quot;,&#10;            dictDir = &quot;&quot;,&#10;            ruleFsts = ruleFsts ?: &quot;&quot;,&#10;            ruleFars = ruleFars ?: &quot;&quot;,&#10;            isKitten = isKitten,&#10;        )!!&#10;&#10;        tts = OfflineTts(assetManager = assets, config = config)&#10;    }&#10;&#10;&#10;    private fun copyDataDir(dataDir: String): String {&#10;        Log.i(TAG, &quot;data dir is $dataDir&quot;)&#10;        copyAssets(dataDir)&#10;&#10;        val newDataDir = application.getExternalFilesDir(null)!!.absolutePath&#10;        Log.i(TAG, &quot;newDataDir: $newDataDir&quot;)&#10;        return newDataDir&#10;    }&#10;&#10;    private fun copyAssets(path: String) {&#10;        val assets: Array&lt;String&gt;?&#10;        try {&#10;            assets = application.assets.list(path)&#10;            if (assets!!.isEmpty()) {&#10;                copyFile(path)&#10;            } else {&#10;                val fullPath = &quot;${application.getExternalFilesDir(null)}/$path&quot;&#10;                val dir = File(fullPath)&#10;                dir.mkdirs()&#10;                for (asset in assets.iterator()) {&#10;                    val p: String = if (path == &quot;&quot;) &quot;&quot; else path + &quot;/&quot;&#10;                    copyAssets(p + asset)&#10;                }&#10;            }&#10;        } catch (ex: IOException) {&#10;            Log.e(TAG, &quot;Failed to copy $path. $ex&quot;)&#10;        }&#10;    }&#10;&#10;    private fun copyFile(filename: String) {&#10;        try {&#10;            val istream = application.assets.open(filename)&#10;            val newFilename = application.getExternalFilesDir(null).toString() + &quot;/&quot; + filename&#10;            val ostream = FileOutputStream(newFilename)&#10;            // Log.i(TAG, &quot;Copying $filename to $newFilename&quot;)&#10;            val buffer = ByteArray(1024)&#10;            var read = 0&#10;            while (read != -1) {&#10;                ostream.write(buffer, 0, read)&#10;                read = istream.read(buffer)&#10;            }&#10;            istream.close()&#10;            ostream.flush()&#10;            ostream.close()&#10;        } catch (ex: Exception) {&#10;            Log.e(TAG, &quot;Failed to copy $filename, $ex&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.k2fsa.sherpa.onnx&#13;&#10;&#13;&#10;import android.animation.ObjectAnimator&#13;&#10;import android.content.res.AssetManager&#13;&#10;import android.graphics.Color&#13;&#10;import android.media.AudioAttributes&#13;&#10;import android.media.AudioFormat&#13;&#10;import android.media.AudioManager&#13;&#10;import android.media.AudioTrack&#13;&#10;import android.media.MediaPlayer&#13;&#10;import android.net.Uri&#13;&#10;import android.os.Bundle&#13;&#10;import android.util.Log&#13;&#10;import android.view.View&#13;&#10;import android.view.animation.AccelerateDecelerateInterpolator&#13;&#10;import android.widget.Button&#13;&#10;import android.widget.EditText&#13;&#10;import android.widget.TextView&#13;&#10;import android.widget.Toast&#13;&#10;import androidx.appcompat.app.AppCompatActivity&#13;&#10;import androidx.cardview.widget.CardView&#13;&#10;import androidx.core.view.WindowCompat&#13;&#10;import com.airbnb.lottie.LottieAnimationView&#13;&#10;import java.io.File&#13;&#10;import java.io.FileOutputStream&#13;&#10;import java.io.IOException&#13;&#10;import java.text.Normalizer&#13;&#10;&#13;&#10;const val TAG = &quot;sherpa-onnx&quot;&#13;&#10;&#13;&#10;class MainActivity : AppCompatActivity() {&#13;&#10;    private var tts: OfflineTts? = null&#13;&#10;    private lateinit var text: EditText&#13;&#10;    private lateinit var sid: EditText&#13;&#10;    private lateinit var speed: EditText&#13;&#10;    private lateinit var generate: Button&#13;&#10;    private lateinit var play: Button&#13;&#10;    private lateinit var stop: Button&#13;&#10;    private var stopped: Boolean = false&#13;&#10;    private var mediaPlayer: MediaPlayer? = null&#13;&#10;    private var isInitialized = false&#13;&#10;&#13;&#10;    // UI Animation elements&#13;&#10;    private lateinit var lottieMic: LottieAnimationView&#13;&#10;    private lateinit var lottieWaveform: LottieAnimationView&#13;&#10;    private lateinit var statusText: TextView&#13;&#10;    private lateinit var mainCard: CardView&#13;&#10;&#13;&#10;    // see&#13;&#10;    // https://developer.android.com/reference/kotlin/android/media/AudioTrack&#13;&#10;    private var track: AudioTrack? = null&#13;&#10;&#13;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#13;&#10;        super.onCreate(savedInstanceState)&#13;&#10;&#13;&#10;        // Enable edge-to-edge display&#13;&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#13;&#10;        window.statusBarColor = Color.TRANSPARENT&#13;&#10;        window.navigationBarColor = Color.TRANSPARENT&#13;&#10;&#13;&#10;        setContentView(R.layout.activity_main)&#13;&#10;&#13;&#10;        initViews()&#13;&#10;        setupClickListeners()&#13;&#10;        startEntranceAnimations()&#13;&#10;&#13;&#10;        // Set default values for hidden fields&#13;&#10;        sid.setText(&quot;0&quot;)&#13;&#10;        speed.setText(&quot;1.0&quot;)&#13;&#10;&#13;&#10;        // Vietnamese sample text for testing TTS&#13;&#10;        val sampleText = &quot;Xin chào, tôi là trợ lý ảo. Rất vui được gặp bạn. Hôm nay thời tiết rất đẹp.&quot;&#13;&#10;        text.setText(sampleText)&#13;&#10;&#13;&#10;        play.isEnabled = false&#13;&#10;        generate.isEnabled = false&#13;&#10;        updateButtonStates()&#13;&#10;&#13;&#10;        // Initialize TTS in background thread&#13;&#10;        Thread {&#13;&#10;            try {&#13;&#10;                Log.i(TAG, &quot;Start to initialize TTS&quot;)&#13;&#10;                initTts()&#13;&#10;                Log.i(TAG, &quot;Finish initializing TTS&quot;)&#13;&#10;&#13;&#10;                Log.i(TAG, &quot;Start to initialize AudioTrack&quot;)&#13;&#10;                initAudioTrack()&#13;&#10;                Log.i(TAG, &quot;Finish initializing AudioTrack&quot;)&#13;&#10;&#13;&#10;                isInitialized = true&#13;&#10;&#13;&#10;                runOnUiThread {&#13;&#10;                    generate.isEnabled = true&#13;&#10;                    updateButtonStates()&#13;&#10;                    showStatus(&quot;✅ Ready to generate speech&quot;)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(TAG, &quot;Failed to initialize TTS: ${e.message}&quot;)&#13;&#10;                runOnUiThread {&#13;&#10;                    showStatus(&quot;❌ Failed to initialize TTS&quot;)&#13;&#10;                    Toast.makeText(this, &quot;Failed to initialize TTS engine&quot;, Toast.LENGTH_LONG).show()&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }.start()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun initViews() {&#13;&#10;        text = findViewById(R.id.text)&#13;&#10;        sid = findViewById(R.id.sid)&#13;&#10;        speed = findViewById(R.id.speed)&#13;&#10;        generate = findViewById(R.id.generate)&#13;&#10;        play = findViewById(R.id.play)&#13;&#10;        stop = findViewById(R.id.stop)&#13;&#10;&#13;&#10;        // Animation elements&#13;&#10;        lottieMic = findViewById(R.id.lottie_mic)&#13;&#10;        lottieWaveform = findViewById(R.id.lottie_waveform)&#13;&#10;        statusText = findViewById(R.id.status_text)&#13;&#10;        mainCard = findViewById(R.id.main_card)&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun setupClickListeners() {&#13;&#10;        generate.setOnClickListener {&#13;&#10;            animateButtonPress(it)&#13;&#10;            onClickGenerate()&#13;&#10;        }&#13;&#10;        play.setOnClickListener {&#13;&#10;            animateButtonPress(it)&#13;&#10;            onClickPlay()&#13;&#10;        }&#13;&#10;        stop.setOnClickListener {&#13;&#10;            animateButtonPress(it)&#13;&#10;            onClickStop()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun animateButtonPress(view: View) {&#13;&#10;        view.animate()&#13;&#10;            .scaleX(0.95f)&#13;&#10;            .scaleY(0.95f)&#13;&#10;            .setDuration(100)&#13;&#10;            .withEndAction {&#13;&#10;                view.animate()&#13;&#10;                    .scaleX(1f)&#13;&#10;                    .scaleY(1f)&#13;&#10;                    .setDuration(100)&#13;&#10;                    .start()&#13;&#10;            }&#13;&#10;            .start()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun startEntranceAnimations() {&#13;&#10;        // Card entrance animation&#13;&#10;        mainCard.alpha = 0f&#13;&#10;        mainCard.translationY = 100f&#13;&#10;        mainCard.animate()&#13;&#10;            .alpha(1f)&#13;&#10;            .translationY(0f)&#13;&#10;            .setDuration(500)&#13;&#10;            .setStartDelay(200)&#13;&#10;            .setInterpolator(AccelerateDecelerateInterpolator())&#13;&#10;            .start()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun showStatus(message: String) {&#13;&#10;        statusText.visibility = View.VISIBLE&#13;&#10;        statusText.text = message&#13;&#10;        statusText.alpha = 0f&#13;&#10;        statusText.animate().alpha(1f).setDuration(200).start()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun showGeneratingState() {&#13;&#10;        runOnUiThread {&#13;&#10;            lottieWaveform.visibility = View.VISIBLE&#13;&#10;            lottieWaveform.playAnimation()&#13;&#10;            showStatus(&quot;️ Generating speech...&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun hideGeneratingState() {&#13;&#10;        runOnUiThread {&#13;&#10;            lottieWaveform.pauseAnimation()&#13;&#10;            lottieWaveform.visibility = View.GONE&#13;&#10;            showStatus(&quot;✅ Speech generated successfully!&quot;)&#13;&#10;            statusText.postDelayed({&#13;&#10;                statusText.animate().alpha(0f).setDuration(300).withEndAction {&#13;&#10;                    statusText.visibility = View.GONE&#13;&#10;                }.start()&#13;&#10;            }, 2000)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun updateButtonStates() {&#13;&#10;        play.alpha = if (play.isEnabled) 1f else 0.5f&#13;&#10;        generate.alpha = if (generate.isEnabled) 1f else 0.5f&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun initAudioTrack() {&#13;&#10;        val sampleRate = tts?.sampleRate() ?: 22050&#13;&#10;        val bufLength = AudioTrack.getMinBufferSize(&#13;&#10;            sampleRate,&#13;&#10;            AudioFormat.CHANNEL_OUT_MONO,&#13;&#10;            AudioFormat.ENCODING_PCM_FLOAT&#13;&#10;        )&#13;&#10;        Log.i(TAG, &quot;sampleRate: $sampleRate, buffLength: $bufLength&quot;)&#13;&#10;&#13;&#10;        val attr = AudioAttributes.Builder().setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)&#13;&#10;            .setUsage(AudioAttributes.USAGE_MEDIA)&#13;&#10;            .build()&#13;&#10;&#13;&#10;        val format = AudioFormat.Builder()&#13;&#10;            .setEncoding(AudioFormat.ENCODING_PCM_FLOAT)&#13;&#10;            .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)&#13;&#10;            .setSampleRate(sampleRate)&#13;&#10;            .build()&#13;&#10;&#13;&#10;        track = AudioTrack(&#13;&#10;            attr, format, bufLength, AudioTrack.MODE_STREAM,&#13;&#10;            AudioManager.AUDIO_SESSION_ID_GENERATE&#13;&#10;        )&#13;&#10;        track?.play()&#13;&#10;    }&#13;&#10;&#13;&#10;    // this function is called from C++&#13;&#10;    private fun callback(samples: FloatArray): Int {&#13;&#10;        if (!stopped) {&#13;&#10;            track?.write(samples, 0, samples.size, AudioTrack.WRITE_BLOCKING)&#13;&#10;            return 1&#13;&#10;        } else {&#13;&#10;            track?.stop()&#13;&#10;            return 0&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun onClickGenerate() {&#13;&#10;        val sidInt = sid.text.toString().toIntOrNull()&#13;&#10;        if (sidInt == null || sidInt &lt; 0) {&#13;&#10;            Toast.makeText(&#13;&#10;                applicationContext,&#13;&#10;                &quot;Please input a non-negative integer for speaker ID!&quot;,&#13;&#10;                Toast.LENGTH_SHORT&#13;&#10;            ).show()&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        val speedFloat = speed.text.toString().toFloatOrNull()&#13;&#10;        if (speedFloat == null || speedFloat &lt;= 0) {&#13;&#10;            Toast.makeText(&#13;&#10;                applicationContext,&#13;&#10;                &quot;Please input a positive number for speech speed!&quot;,&#13;&#10;                Toast.LENGTH_SHORT&#13;&#10;            ).show()&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        var textStr = text.text.toString().trim()&#13;&#10;        if (textStr.isBlank() || textStr.isEmpty()) {&#13;&#10;            Toast.makeText(applicationContext, &quot;Please input a non-empty text!&quot;, Toast.LENGTH_SHORT)&#13;&#10;                .show()&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        // Normalize Vietnamese text to NFC form for proper diacritic handling&#13;&#10;        textStr = Normalizer.normalize(textStr, Normalizer.Form.NFC)&#13;&#10;&#13;&#10;        track?.pause()&#13;&#10;        track?.flush()&#13;&#10;        track?.play()&#13;&#10;&#13;&#10;        play.isEnabled = false&#13;&#10;        generate.isEnabled = false&#13;&#10;        stopped = false&#13;&#10;        showGeneratingState()&#13;&#10;        Thread {&#13;&#10;            val audio = tts?.generateWithCallback(&#13;&#10;                text = textStr,&#13;&#10;                sid = sidInt,&#13;&#10;                speed = speedFloat,&#13;&#10;                callback = this::callback&#13;&#10;            )&#13;&#10;&#13;&#10;            val filename = application.filesDir.absolutePath + &quot;/generated.wav&quot;&#13;&#10;            val ok = audio?.samples?.size ?: 0 &gt; 0 &amp;&amp; audio?.save(filename) == true&#13;&#10;            if (ok) {&#13;&#10;                runOnUiThread {&#13;&#10;                    hideGeneratingState()&#13;&#10;                    play.isEnabled = true&#13;&#10;                    generate.isEnabled = true&#13;&#10;                    track?.stop()&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }.start()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun onClickPlay() {&#13;&#10;        val filename = application.filesDir.absolutePath + &quot;/generated.wav&quot;&#13;&#10;        mediaPlayer?.stop()&#13;&#10;        mediaPlayer = MediaPlayer.create(&#13;&#10;            applicationContext,&#13;&#10;            Uri.fromFile(File(filename))&#13;&#10;        )&#13;&#10;        mediaPlayer?.start()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun onClickStop() {&#13;&#10;        stopped = true&#13;&#10;        play.isEnabled = true&#13;&#10;        generate.isEnabled = true&#13;&#10;        track?.pause()&#13;&#10;        track?.flush()&#13;&#10;        mediaPlayer?.stop()&#13;&#10;        mediaPlayer = null&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun initTts() {&#13;&#10;        var modelDir: String?&#13;&#10;        var modelName: String?&#13;&#10;        var acousticModelName: String?&#13;&#10;        var vocoder: String?&#13;&#10;        var voices: String?&#13;&#10;        var ruleFsts: String?&#13;&#10;        var ruleFars: String?&#13;&#10;        var lexicon: String?&#13;&#10;        var dataDir: String?&#13;&#10;        var assets: AssetManager? = application.assets&#13;&#10;        var isKitten = false&#13;&#10;&#13;&#10;        // The purpose of such a design is to make the CI test easier&#13;&#10;        // Please see&#13;&#10;        // https://github.com/k2-fsa/sherpa-onnx/blob/master/scripts/apk/generate-tts-apk-script.py&#13;&#10;&#13;&#10;        // VITS -- begin&#13;&#10;        modelName = null&#13;&#10;        // VITS -- end&#13;&#10;&#13;&#10;        // Matcha -- begin&#13;&#10;        acousticModelName = null&#13;&#10;        vocoder = null&#13;&#10;        // Matcha -- end&#13;&#10;&#13;&#10;        // For Kokoro -- begin&#13;&#10;        voices = null&#13;&#10;        // For Kokoro -- end&#13;&#10;&#13;&#10;&#13;&#10;        modelDir = null&#13;&#10;        ruleFsts = null&#13;&#10;        ruleFars = null&#13;&#10;        lexicon = null&#13;&#10;        dataDir = null&#13;&#10;&#13;&#10;//&#13;&#10;//        modelDir = &quot;exported&quot;&#13;&#10;//        modelName = &quot;model_fixed.onnx&quot;&#13;&#10;//        dataDir = &quot;exported/espeak-ng-data&quot;&#13;&#10;&#13;&#10;        // Working Piper model (backup):&#13;&#10;         modelDir = &quot;vits-piper-vi_VN-vais1000-medium&quot;&#13;&#10;         modelName = &quot;vi_VN-vais1000-medium.onnx&quot;&#13;&#10;         dataDir = &quot;vits-piper-vi_VN-vais1000-medium/espeak-ng-data&quot;&#13;&#10;&#13;&#10;        // Example 1:&#13;&#10;        // modelDir = &quot;vits-vctk&quot;&#13;&#10;        // modelName = &quot;vits-vctk.onnx&quot;&#13;&#10;        // lexicon = &quot;lexicon.txt&quot;&#13;&#10;&#13;&#10;        // Example 2:&#13;&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/tag/tts-models&#13;&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/vits-piper-en_US-amy-low.tar.bz2&#13;&#10;        // modelDir = &quot;vits-piper-en_US-amy-low&quot;&#13;&#10;        // modelName = &quot;en_US-amy-low.onnx&quot;&#13;&#10;        // dataDir = &quot;vits-piper-en_US-amy-low/espeak-ng-data&quot;&#13;&#10;&#13;&#10;        // Example 3:&#13;&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/vits-icefall-zh-aishell3.tar.bz2&#13;&#10;        // modelDir = &quot;vits-icefall-zh-aishell3&quot;&#13;&#10;        // modelName = &quot;model.onnx&quot;&#13;&#10;        // ruleFars = &quot;vits-icefall-zh-aishell3/rule.far&quot;&#13;&#10;        // lexicon = &quot;lexicon.txt&quot;&#13;&#10;&#13;&#10;        // Example 4:&#13;&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/vits.html#csukuangfj-vits-zh-hf-fanchen-c-chinese-187-speakers&#13;&#10;        // modelDir = &quot;vits-zh-hf-fanchen-C&quot;&#13;&#10;        // modelName = &quot;vits-zh-hf-fanchen-C.onnx&quot;&#13;&#10;        // lexicon = &quot;lexicon.txt&quot;&#13;&#10;&#13;&#10;        // Example 5:&#13;&#10;        // https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/vits-coqui-de-css10.tar.bz2&#13;&#10;        // modelDir = &quot;vits-coqui-de-css10&quot;&#13;&#10;        // modelName = &quot;model.onnx&quot;&#13;&#10;&#13;&#10;        // Example 6&#13;&#10;        // vits-melo-tts-zh_en&#13;&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/vits.html#vits-melo-tts-zh-en-chinese-english-1-speaker&#13;&#10;        // modelDir = &quot;vits-melo-tts-zh_en&quot;&#13;&#10;        // modelName = &quot;model.onnx&quot;&#13;&#10;        // lexicon = &quot;lexicon.txt&quot;&#13;&#10;&#13;&#10;        // Example 7&#13;&#10;        // matcha-icefall-zh-baker&#13;&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/matcha.html#matcha-icefall-zh-baker-chinese-1-female-speaker&#13;&#10;        // modelDir = &quot;matcha-icefall-zh-baker&quot;&#13;&#10;        // acousticModelName = &quot;model-steps-3.onnx&quot;&#13;&#10;        // vocoder = &quot;vocos-22khz-univ.onnx&quot;    // Vocoder should be downloaded separately; place in the **root directory of your resources folder**, not under modelDir.&#13;&#10;        // lexicon = &quot;lexicon.txt&quot;&#13;&#10;&#13;&#10;        // Example 8&#13;&#10;        // matcha-icefall-en_US-ljspeech&#13;&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/pretrained_models/matcha.html#matcha-icefall-en-us-ljspeech-american-english-1-female-speaker&#13;&#10;        // modelDir = &quot;matcha-icefall-en_US-ljspeech&quot;&#13;&#10;        // acousticModelName = &quot;model-steps-3.onnx&quot;&#13;&#10;        // vocoder = &quot;vocos-22khz-univ.onnx&quot;&#13;&#10;        // dataDir = &quot;matcha-icefall-en_US-ljspeech/espeak-ng-data&quot;&#13;&#10;&#13;&#10;        // Example 9&#13;&#10;        // kokoro-en-v0_19&#13;&#10;        // modelDir = &quot;kokoro-en-v0_19&quot;&#13;&#10;        // modelName = &quot;model.onnx&quot;&#13;&#10;        // voices = &quot;voices.bin&quot;&#13;&#10;        // dataDir = &quot;kokoro-en-v0_19/espeak-ng-data&quot;&#13;&#10;&#13;&#10;        // Example 10&#13;&#10;        // kokoro-multi-lang-v1_0&#13;&#10;        // modelDir = &quot;kokoro-multi-lang-v1_0&quot;&#13;&#10;        // modelName = &quot;model.onnx&quot;&#13;&#10;        // voices = &quot;voices.bin&quot;&#13;&#10;        // dataDir = &quot;kokoro-multi-lang-v1_0/espeak-ng-data&quot;&#13;&#10;        // lexicon = &quot;kokoro-multi-lang-v1_0/lexicon-us-en.txt,kokoro-multi-lang-v1_0/lexicon-zh.txt&quot;&#13;&#10;        // ruleFsts = &quot;$modelDir/phone-zh.fst,$modelDir/date-zh.fst,$modelDir/number-zh.fst&quot;&#13;&#10;&#13;&#10;        // Example 11&#13;&#10;        // kitten-nano-en-v0_1-fp16&#13;&#10;        // modelDir = &quot;kitten-nano-en-v0_1-fp16&quot;&#13;&#10;        // modelName = &quot;model.fp16.onnx&quot;&#13;&#10;        // voices = &quot;voices.bin&quot;&#13;&#10;        // dataDir = &quot;kokoro-multi-lang-v1_0/espeak-ng-data&quot;&#13;&#10;        // isKitten = true&#13;&#10;&#13;&#10;        // Example 12&#13;&#10;        // matcha-icefall-zh-en&#13;&#10;        // https://k2-fsa.github.io/sherpa/onnx/tts/all/Chinese-English/matcha-icefall-zh-en.html&#13;&#10;        // modelDir = &quot;matcha-icefall-zh-en&quot;&#13;&#10;        // acousticModelName = &quot;model-steps-3.onnx&quot;&#13;&#10;        // vocoder = &quot;vocos-16khz-univ.onnx&quot;    // Vocoder should be downloaded separately; place in the **root directory of your resources folder**, not under modelDir.&#13;&#10;        // dataDir = &quot;matcha-icefall-zh-en/espeak-ng-data&quot;&#13;&#10;        // lexicon = &quot;lexicon.txt&quot;&#13;&#10;&#13;&#10;        if (dataDir != null) {&#13;&#10;            val newDir = copyDataDir(dataDir!!)&#13;&#10;            dataDir = &quot;$newDir/$dataDir&quot;&#13;&#10;        }&#13;&#10;&#13;&#10;        val config = getOfflineTtsConfig(&#13;&#10;            modelDir = modelDir!!,&#13;&#10;            modelName = modelName ?: &quot;&quot;,&#13;&#10;            acousticModelName = acousticModelName ?: &quot;&quot;,&#13;&#10;            vocoder = vocoder ?: &quot;&quot;,&#13;&#10;            voices = voices ?: &quot;&quot;,&#13;&#10;            lexicon = lexicon ?: &quot;&quot;,&#13;&#10;            dataDir = dataDir ?: &quot;&quot;,&#13;&#10;            dictDir = &quot;&quot;,&#13;&#10;            ruleFsts = ruleFsts ?: &quot;&quot;,&#13;&#10;            ruleFars = ruleFars ?: &quot;&quot;,&#13;&#10;            isKitten = isKitten,&#13;&#10;        )!!&#13;&#10;&#13;&#10;        tts = OfflineTts(assetManager = assets, config = config)&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    private fun copyDataDir(dataDir: String): String {&#13;&#10;        Log.i(TAG, &quot;data dir is $dataDir&quot;)&#13;&#10;        copyAssets(dataDir)&#13;&#10;&#13;&#10;        val newDataDir = application.getExternalFilesDir(null)!!.absolutePath&#13;&#10;        Log.i(TAG, &quot;newDataDir: $newDataDir&quot;)&#13;&#10;        return newDataDir&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun copyAssets(path: String) {&#13;&#10;        val assets: Array&lt;String&gt;?&#13;&#10;        try {&#13;&#10;            assets = application.assets.list(path)&#13;&#10;            if (assets!!.isEmpty()) {&#13;&#10;                copyFile(path)&#13;&#10;            } else {&#13;&#10;                val fullPath = &quot;${application.getExternalFilesDir(null)}/$path&quot;&#13;&#10;                val dir = File(fullPath)&#13;&#10;                dir.mkdirs()&#13;&#10;                for (asset in assets.iterator()) {&#13;&#10;                    val p: String = if (path == &quot;&quot;) &quot;&quot; else path + &quot;/&quot;&#13;&#10;                    copyAssets(p + asset)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (ex: IOException) {&#13;&#10;            Log.e(TAG, &quot;Failed to copy $path. $ex&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun copyFile(filename: String) {&#13;&#10;        try {&#13;&#10;            val istream = application.assets.open(filename)&#13;&#10;            val newFilename = application.getExternalFilesDir(null).toString() + &quot;/&quot; + filename&#13;&#10;            val ostream = FileOutputStream(newFilename)&#13;&#10;            // Log.i(TAG, &quot;Copying $filename to $newFilename&quot;)&#13;&#10;            val buffer = ByteArray(1024)&#13;&#10;            var read = 0&#13;&#10;            while (read != -1) {&#13;&#10;                ostream.write(buffer, 0, read)&#13;&#10;                read = istream.read(buffer)&#13;&#10;            }&#13;&#10;            istream.close()&#13;&#10;            ostream.flush()&#13;&#10;            ostream.close()&#13;&#10;        } catch (ex: Exception) {&#13;&#10;            Log.e(TAG, &quot;Failed to copy $filename, $ex&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/btn_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/btn_outline.xml" />
              <option name="originalContent" value="        &lt;shape android:shape=&quot;rectangle&quot;&gt;&#10;            &lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&#10;            &lt;corners android:radius=&quot;28dp&quot; /&gt;&#10;            &lt;stroke&#10;                android:width=&quot;2dp&quot;&#10;                android:color=&quot;@color/primary&quot; /&gt;&#10;        &lt;/shape&gt;&#10;    &lt;/item&gt;&#10;&lt;/ripple&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:color=&quot;#20000000&quot;&gt;&#10;    &lt;item&gt;&#10;        &lt;shape android:shape=&quot;rectangle&quot;&gt;&#10;            &lt;solid android:color=&quot;#FFFFFF&quot; /&gt;&#10;            &lt;corners android:radius=&quot;28dp&quot; /&gt;&#10;            &lt;stroke&#10;                android:width=&quot;2dp&quot;&#10;                android:color=&quot;@color/primary&quot; /&gt;&#10;        &lt;/shape&gt;&#10;    &lt;/item&gt;&#10;&lt;/ripple&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>